Console. methoden
.Write
.WriteLine  echo // is the same thing
.Read
.Readline

"Klasse" "name" = new() [Klasse]; // erstellen von einer Klasse 
Random dice = new Random()

Random // Klasse zum generieren von Zufälligen nicht negativen Ganzzahlen
.Next(Minimum, Maximum) // Generiert eine nummer für das verbundende Integer

Datatypes
Type        Discription                                             Size(bytes)     .NET type       Range

int         Whole numbers                                           4               System.Int32    -2,147,483,648 - 2,147,483,648
long        Whole numbers(Bigger range)                             8               System.Int64    -9,223,372,036,854,775,808 - 9,223,372,036,854,775,808
float       Floating point numbers                                  4               System.Single   +- 3,4 x 10^38
double      Double precision(more accurate)floating point numbers   8               System.Double   +- 1.7 x 10^308
decimal     Monetary values                                         16              System.decimal  28 significant figures      (needs an m in the end)
char        Single character                                        2               System.char     N/A 
bool        Boolean                                                 1               System.Boolean  True or False
DateTime    Moments in time                                         8               System.DateTime 0:0:00 on 01/01/0001 to 23:59:59 on 12/31/9999
string      Sequence of characters                                  2 per character System.String   N/A

data.Length         // länge einer string
data.IndexOf()      // position eines zeichens 
data.Substring()    // gibt substring("wörter") wieder
data.ToUpper()      // konvertiert zeichenketten zu großgeschriebene zeichenketten
data.ToLower()      // konvertiert zeichenketten zu kleingeschriebene zeichenketten

$"blah blah"        // interpolation


string[i]           //i starts counting at 0, outputs letter of the index

Convert.ToDouble()  //String zu Double Beispiel
Convert.ToInt32()   //String zu Int

integer++           //Plus 1
integer--           //Minus 1
integer +=          //Plus
integer -=          //Minus 
integer /=          //Geteilt durch
integer *=          //Multipliziert mit


==  equal           gleich
<   less            kleiner als
>   more            größer als
<=  less or equal   kleiner oder gleich als    
>=  more or equal   größer oder gleich als

&&  and             und
||  or              oder

if                  //Wenn
else                //Sonst

switch()            //Falls ... eintritt
case                //Optionen bzw. fall    e.g ||      case "red": break;      "case 1: case 2: break;" ist möglich (verketten)
return              // ist möglich anstatt break;
break;              //bricht einen prozess ab bzw. verlässt eine schleife                                                       

Ternary Operators   // if else aber kürzer geschrieben
string color = "blue";
string result = (color == "blue") ? "blue" : "NOT blue";    // Ausgabe wäre hier: blue | "?" wäre hier ein IF und ":" ein else

static void methodname(string parameter = "something",string a = "a" , int b = 3, int c = 5){             // Falls der Parameter einen default hat, ist dieser optional und bei neu bestimmung überschrieben
                                                                                                          // static = unbeweglich, void = wirft kein "return" zurück
}

methodname("hi",b:6)            // in diesen fall something wird überschrieben, a bleibt gleich, b wird 6 und c bleibt 5
methodname(b:6, "hi")           // wirft ein fehler weil positionseingaben anschließend nur angenommen werden                   // weitere test hier, was passiert wenn 4 parameter existieren UND wir haben pos. argumente und normale argumente ?

Method Overloading 
=> Erstelle methoden mit selben namen + parameter und inhalt sind unterschiedlich.
Durch aufrufen der methode wird überprüft welche übereinstimmt und wird ausgeführt
-> Versionen von methode
-> Kann unterschiedliche : 
    -> Parameter Typen sein 
    -> Parameter Anzahl sein

Method Outputs:
Static string variable(){       // Wirft eine Zeichenkette zurück
    return "example";
}

Method output out
e.g 
int number;
bool variable1 = Int32.TryParse("10502", out number);
// number ist 10502 und variable1 ist true(wahr)
int number2;
bool variable2 = Int32.TryParse(" !!! ", out number2);
// number2 ist 0 und success ist false(falsch)
// warum ? weil in der methode eine variable bearbeitet wurde und diese zusätzlich ausgeworfen wird.
// Das heißt hier die Methode versucht eine variable zu überprüfen. Diese muss eine Zahl sein um die zweite variable als wahr wiederzugeben.
// tl:dr wirft eine zweite variable aus die nutzbar ist. Eine art von zweiter "return"

// vereinfachte erklärung.
Eine methode mit "out" hat die function variablen wiederzugeben.
Siehe hier : 

int beispielOutZahl;    // initieren einer variable zum speichern des out parameter
Methode("Beispiel", out beispielOutZahl)        // wirft das out in unsere initierte variable

static void Methode(string beispielString, out int beispielWiedergabe){     // gibt die beispielWiedergabe in die BeispielOutZahl(die oben initiert wurde)
    beispielWiedergabe = beispielString.Length;                             // konvertiert zeichenkettelänge zu zahl
}                                                                           // das beispiel hätte man natürlich sehr einfach schreiben könnne mit einer methode ohne void und mit "return beispielString.Length;"

// wichtige notiz hier: die out variable wird von der methode an sich initialisiert
bei dem Aufruf der Methode kann man eine variable auch initialisieren nach dem "out"

Expression-bodied Definitions

anstatt:
//bool IsEven(int num)
//{
//  return num % 2 == 0;
//}

//bool isEven(int num) => num % 2 == 0;             // Der Pfeil ersätzt die {} und return, zum Aufrufen muss man nur "isEven(2);" schreiben

Array.Exists()          //Überprüft nach arrays und gibt einen Boolean aus wenn er einen entdeckt       // aufgerufene Methode darf keine klammern() enthalten!
                        //Man kann sich vorstellen das der erste Parameter wiederholt ausgelesen wird und z.B Methode(Beispiel1) , Methode(Beispiel2) Methode(Beispiel3) aufruft
                        //Wobei die Methode an sich die (Beispiel1), ... selbst aufbringt

Lambda Expressions
(input-parameters) => expression            //Einfache verwendung

bool hasEvenNumber = Array.Exists(numbers, (int num) => num % 2 == 0 );


(input-parameters) => { statement; }        //Mehrfache verwendung (mehrere variablen etc.)

bool hasBigDozen = Array.Exists(numbers, (int num) => {
  bool isDozenMultiple = num % 12 == 0;
  bool greaterThan20 = num > 20;
  return isDozenMultiple && greaterThan20;
});

//bei einfachen lambda Methoden mit nur einem Parameter benötigt man keine Klammer
// ein typ eines parameters kann ggbf. ausgelassen werden falls genug bestimmt ist bsp. 's => s = "beispiel"' benötigt keine string angabe// mehr recherche hier //

Arrays
bestimmung:
typ[] beispielName = {1,2,3};   //typ wäre hier int die eckigen klammern danach bestimmt ein array
typ[] beispielName = new int[] {3,4,5}  // bestimmt mit der "new" keyword ein array neu

// Initial declaration
int[] plantHeights;

// This works
plantHeights = new int[] { 3, 4, 6 };  

probleme die eintretten könnne
// This will cause an error
// plantHeights = { 3, 4, 6 }; 

